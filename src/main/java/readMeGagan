1. In order to intercept request sent and response receive by invoking rest template , we have defined an interceptor
MovieCatalogueInterceptor which implements ClientHttpRequestInterceptor.

ClientHttpRequestInterceptor interface is a functional interface with only one method 
public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)

Here we have logged request details like request method , request body , response hedaers etc.

Most Imp-> After creating a interceptor , we need to instantiate it and tag it to restTemplate whose request/response it will intercept
by invoking restTempalte.setInterceptor(List<ClientHttpRequestInterceptor> )

here in our code
r.setInterceptors(Arrays.asList(new MovieCatalogueInterceptor()));

2.
 Map<String, String> m = Stream.of("user").collect(Collectors.toMap(a -> a, a
		// -> "gagan"));
Above will create Map with entry(key=user, value=gagan)

3.Multiple request headers, query/request param can be sent through restTemplate as MutiValueMap. MultiValueMap is an interface
whose implementation class is LinkedMultiValueMap.

The headers can be provided as HttpEntity(T body, MultiValueMap<String,String> headers)
and then RestTemplate method
<T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType, Map<String,?> uriVariables)

Similarly queryParam/requestParam can be passed as MultiValueMap to URI

MultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>();
		multiValueMap.add("user", userName);
		String url = UriComponentsBuilder.fromHttpUrl(ratingDataServiceURL).queryParams(multiValueMap).toUriString()
		
		This url will have query string i.e ww.abc.com?k1=v1&k2=v2...
		where k1,v1 ; k2,v2 .. are entries in MultiValueMap supplied to URIComponentBuilder
		
This url as string can be passed to any method of resttemplate

4.In 
https://www.baeldung.com/spring-rest-template-list
<T> ResponseEntity<T>	exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType, Map<String,?> uriVariables)

The response object is encapsulated by Class<T> responseType but lets suppose here it is Collection<GenericType>
lets say List<MovieRating> then you will have to instantiate annonymous inner class as
new ParameterizedTypeReference<List<MovieRating>>() {
				} 
i.e new ParameterizedTypeReference<T>() {
				} 
where T is Collection<Q>

and hence go as
ResponseEntity<List<Employee>> response = restTemplate.exchange(
  "http://localhost:8080/employees/",
  HttpMethod.GET,
  null,
  new ParameterizedTypeReference<List<Employee>>(){});				

 5. Spring boot comes with a client already in classpath-RestTemplate
 
 6.
 For using WebClient as RestTemplate will be deprecated we need to add dependency 
 
 <dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
		
and then WebClient webClient=WebClient.create()
 
 Spring WebFlux is a fully non-blocking reactive alternative to Spring MVC.
 List<A>,Collection<A>,Set<A> etc--> Flux<A>
 Single Value -> Mono
 https://stackoverflow.com/questions/56029123/spring-webclient-customised-response-callback-on-http-error-status
 https://dzone.com/articles/doing-stuff-with-spring-webflux
 https://www.e4developer.com/2018/05/31/webflux-in-practice-asynchronous-service-with-webclient/
 
 7.Why hardcoded URLs are bad?
 Dynamic URLs in cloud
 Multiple environments, multiple url
 Multiple instances with different urls while loadbalancing
 
 8. Types of service Discovery:
 Client Side Service Discovery-> Disc Server returns address/URL of service asked by client
 and then client directly hits that service by invoking the provided URL/address.
 
 Server Side Service Discovery-> Disc. Server acts as intermediate b/w service and client 
 and routes requests from client to service. This is efficient as less hops.
 Spring cloud uses client side service discovery
 
 9. Steps of Service Discovery through Netflix provided Eureka technology
a)Start up Eureka Server
b)Have microservices register(publish) using Eureka client
c)Have microservices locate(consume) using Eureka client

Thereafter read 10 readMeGagan from Microservices_EurekaServer project

13. Consuming services with eureka client name
You can now call the service by just providing the eureka client name and
not give complete URL as we have url as defined in application.proprties file i.e
ratingDataServiceEurekaClientNamedUrl=http://MOVIE-RATING-DATA-SERVICE/rating
movieInfoServiceEurekaClientNamedUrl=http://MOVIE-INFO-SERVICE/movies/info

The RestTemplate bean by which we are invoking these services should be annotated
with @LoadBalanced
@LoadBalanced=ServiceDiscovery+Load Balancing(at client side)

The restTemplate will take care of finding service url. It will provide abstraction
while invoking service by first calling eureka server to get service url of service
and then invoking the service through obtained service url.You don't have to do anything.

It does load balancing at client side in the sense once Eureka server returns that there are n 
instances for this service(service id) , the it automatically chooses one instance based on some
load balancing logic and then hits that instance.

14.Eureka client sends heart beats to service registry/eureka server periodically 
to register its presence

15.How to fetch all services name at runtime?How to customize load balancing(other than @LoadBalanced)?
DiscoveryClient https://spring.io/guides/gs/service-registration-and-discovery/

Discovery client is an interface 

In above spring documentation link , com.netflix.discovery.DiscoveryClient of netflix 
library is used to fetch all services at runtime but this is not working practically 
as we are getting no such bean  exception on Autowiring it (not even lazy autowiring 
is working) 

The alternate to it is using org.springframework.cloud.client.discovery.DiscoveryClient
from spring cloud and getting its instance by autowiring it.

Now you get all services name at runtime by invoking 
List<String> discoveryClient.getServices() 
eg will give [MOVIE-CATALOGUE-SERVICE,MOVIE-INFO-SERVICE,MOVIE-RATING-DATA-SERVICE]

You can get url of all instances of a given service by calling
List<ServiceInstance> discoveryClient.getInstances("MOVIE-INFO-SERVICE")

And  then  extract url by serviceInstance.getUri();
will return http://HarinderBudhiraja:9999

discoveryClient_springCloud.getInstances("MOVIE-INFO-SERVICE").forEach(serviceInstance -> {
			System.out.println(serviceInstance.getUri().toString());
		});

Using above approach you can chose which instance you wish to invoke and customize load balancing

16. We can spawn multiple instances of a service by doing

a)Create jar file by executing
mvn install 
b)Run this jar on specified port (i.e override port as defined in application.properties file)
java  -Dserver.port=9999 -jar movie-info-0.0.1-SNAPSHOT.jar

-Dxxx=xValue is used to provide property in java. It is for any property.

These multiple instances on getting spawned on distinct ports will be displayed on Eureka server
UI at loaclhost:8761

17. Function.identity() is just a shortcut for defining a function that accepts 
and returns the same value. We have used in stream api.

18. In case Eureka server goes down, eureka client can get the service url from its cache